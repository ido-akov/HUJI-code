Activation.h����������������������������������������������������������������������������������������000755 �000765 �000024 �00000002234 13670724103 014467� 0����������������������������������������������������������������������������������������������������ustar�00tamarakov�����������������������staff���������������������������000000 �000000 ������������������������������������������������������������������������������������������������������������������������������������������������������������������������#include "Matrix.h"

#ifndef ACTIVATION_H
#define ACTIVATION_H

/**
 * @enum ActivationType
 * @brief Indicator of activation function.
 */
enum ActivationType
{
	Relu,
	Softmax
};

/**
 * class for activating function on matrix
 */
class Activation
{
private:
	ActivationType _type;

	/**
	 * helper function for Softmax function activation on matrix
	 * @param m matrix to activate function on
	 * @return matrix with updated values
	 */
	static Matrix _activateSoftmax(const Matrix &m);

	/**
	 * helper function for Relu function activation on matrix
	 * @param m matrix to activate function on
	 * @return matrix with updated values
	 */
	static Matrix _activateRelu(const Matrix &m);

public:
/**
 * constructor for class
 * @param type ActivationType function
 */
	explicit Activation(ActivationType type) : _type(type)
	{}

	/**
	 * Getter method
	 * @return activation type
	 */
	ActivationType &getActivationType()
	{ return _type; }

	/**
	 * parenthesis operator for class: activate this instance's activationType function on
	 * matrix input
	 * @param m matrix
	 * @return matrix with updated vals
	 */
	Matrix operator()(const Matrix &m);
};

#endif //ACTIVATION_H
��������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������Activation.cpp��������������������������������������������������������������������������������������000644 �000765 �000024 �00000002254 13670724106 015024� 0����������������������������������������������������������������������������������������������������ustar�00tamarakov�����������������������staff���������������������������000000 �000000 ������������������������������������������������������������������������������������������������������������������������������������������������������������������������#include "Activation.h"
#include <cmath>

using std::exp;

/**
     * helper function for Relu function activation on matrix
     * @param m matrix to activate function on
     * @return matrix with updated values
     */
Matrix Activation::_activateRelu(const Matrix &m)
{
	Matrix res = Matrix(m);
	for (int i = 0; i < res.getRows() * res.getCols(); i++)
	{
		//return max between x and 0
		res[i] = fmaxf(res[i], 0.f);
	}
	return res;
}

/**
 * helper function for Softmax function activation on matrix
 * @param m matrix to activate function on
 * @return matrix with updated values
 */
Matrix Activation::_activateSoftmax(const Matrix &m)
{
	Matrix res = Matrix(m);
	float sum = 0.0f;
	for (int i = 0; i < res.getRows() * res.getCols(); i++)
	{
		res[i] = exp(m[i]);
		sum += res[i];
	}
	float normalize = 1 / sum;
	//normalize matrix values by multiplication by a scalar
	return normalize * res;
}

/**
	 * activate this instance's activationType function on matrix input.
	 * @param m matrix
	 * @return matrix with updated vals
	 */
Matrix Activation::operator()(const Matrix &m)
{
	switch (_type)
	{
		case Relu:
			return _activateRelu(m);
		default:
			return _activateSoftmax(m);
	}
}
����������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������Dense.cpp�������������������������������������������������������������������������������������������000644 �000765 �000024 �00000000371 13670724075 013764� 0����������������������������������������������������������������������������������������������������ustar�00tamarakov�����������������������staff���������������������������000000 �000000 ������������������������������������������������������������������������������������������������������������������������������������������������������������������������
#include "Dense.h"

/**
     * activate layer on input matrix.
     * @param inp matrix
     * @return output matrix with result of activation of layer
     */
Matrix Dense::operator()(const Matrix &inp)
{
	return _act((_weights * inp) + _bias);
}
�����������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������Dense.h���������������������������������������������������������������������������������������������000644 �000765 �000024 �00000002047 13670724075 013433� 0����������������������������������������������������������������������������������������������������ustar�00tamarakov�����������������������staff���������������������������000000 �000000 ������������������������������������������������������������������������������������������������������������������������������������������������������������������������//
// Created by Tamar Akov on 6/11/20.
//

#ifndef EX4_DENSE_H
#define EX4_DENSE_H

#include "Matrix.h"
#include "Activation.h"

/**
 * This class describes a layer in a network.
 */
class Dense
{
private:
	Matrix _weights, _bias;
	Activation _act;

public:
	/**
	 * class constructor
	 * @param w weights matrix
	 * @param b bias matrix(vector)
	 * @param a activationType function
	 */
	Dense(const Matrix &w, const Matrix &b, ActivationType a) : _weights(w), _bias(b), _act(a)
	{}

	/**
	 * getter method
	 * @return weights matrix
	 */
	const Matrix &getWeights() const
	{ return _weights; }

	/**
	 * getter method
	 * @return bias vector
	 */
	const Matrix &getBias() const
	{ return _bias; }

	/**
	 * getter method
	 * @return Activation member with activationType function
	 */
	const Activation &getActivation() const
	{ return _act; }

	/**
	 * parenthesis operator: activate layer on input matrix
	 * @param inp matrix
	 * @return output matrix with result of activation of layer
	 */
	Matrix operator()(const Matrix &inp);
};


#endif //EX4_DENSE_H
�����������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������Matrix.cpp������������������������������������������������������������������������������������������000644 �000765 �000024 �00000014700 13670724065 014172� 0����������������������������������������������������������������������������������������������������ustar�00tamarakov�����������������������staff���������������������������000000 �000000 ������������������������������������������������������������������������������������������������������������������������������������������������������������������������#include "Matrix.h"

/**
     * c'tor- constructs Matrix rows × cols, inits all elements to 0
     */
Matrix::Matrix(int rows, int cols)
{
	if (rows <= 0 || cols <= 0)
	{
		//return error, exit
		Matrix::_errorMsg(MATRIX_DIMS_ERROR);
	}
	_dims.rows = rows;
	_dims.cols = cols;
	//allocate array on heap
	_data = new float[rows * cols]();
}

/**
     * helper function- copies all data into another matrix
     * @param m matrix from which data is to be copied
     */
void Matrix::_matrixDeepCopy(const Matrix &m)
{
	for (int i = 0; i < _dims.cols * _dims.rows; i++)
	{
		(*this)[i] = m[i];
	}
}

/**
     * function makes a matrix of dimensions (m,n) into a vector of dimensions (m*n,1)
     * @return vector version of matrix
     */
Matrix &Matrix::vectorize()
{
	_dims.rows *= _dims.cols;
	_dims.cols = DEFAULT_DIM;
	return *this;
}

/**
     *  Prints matrix elements, no return value. Prints space after each element (incl. last
     *  element in the row). Prints newline after each row (incl. last row)
     */
void Matrix::plainPrint() const
{
	for (int i = 0; i < _dims.rows; i++)
	{
		for (int j = 0; j < _dims.cols; j++)
		{
			std::cout << (*this)(i, j) << SPACE;
		}
		std::cout << std::endl;
	}
}

/**
     * assignment operator for matrices
     * @param rhs matrix from which to assign dimensions and values
     * @return this matrix with updated dims and values
     */
Matrix &Matrix::operator=(const Matrix &rhs)
{
	if (this == &rhs)
	{
		//self assignment
		return *this;
	}
	//_data always has a value because of default constructor
	delete[] _data;
	//default assignment
	_dims = rhs._dims;
	_data = new float[_dims.rows * _dims.cols];
	//copy values to this matrix
	_matrixDeepCopy(rhs);
	return *this;
}

/**
     * multiplication operator for matrices- must be of form M(m,n) * N(n,k)
     * @param rhs matrix to multiply by
     * @return new matrix with multiplication values
     */
Matrix Matrix::operator*(const Matrix &rhs) const
{
	if (_dims.cols != rhs.getRows())
	{
		//matrices can't be multiplied
		Matrix::_errorMsg(MATRIX_MULT_ERROR);
	}
	//create new empty matrix with correct dimensions to store within values
	Matrix res = Matrix(_dims.rows, rhs.getCols());
	for (int i = 0; i < res.getRows(); i++)
	{
		for (int j = 0; j < res.getCols(); j++)
		{
			float sum = 0.0f;
			for (int k = 0; k < _dims.cols; k++)
			{
				//matrix multiplication formula
				sum += (*this)(i, k) * rhs(k, j);
			}
			res(i, j) = sum;
		}
	}
	return res;
}

/**
     * Scalar multiplication by right operator for matrices
     * @param rhs scalar by which to multiply all values in matrix
     * @return this matrix
     */
Matrix &Matrix::operator*(const float &rhs)
{
	for (int i = 0; i < _dims.cols * _dims.rows; i++)
	{
		(*this)[i] *= rhs;
	}
	return *this;
}

/**
     * Scalar multiplication by left operator for matrices
     * @param rhs scalar by which to multiply all values in matrix
     * @return matrix
     */
Matrix &operator*(const float lhs, Matrix &rhs)
{
	for (int i = 0; i < rhs.getRows() * rhs.getCols(); i++)
	{
		rhs[i] *= lhs;
	}
	return rhs;
}

/**
     * Matrix addition operator. Both matrices must be of dims (m,n)
     * @param rhs matrix to add to this matrix
     * @return matrix with updated values
     */
Matrix Matrix::operator+(const Matrix &rhs) const
{
	if (_dims.rows != rhs.getRows() || _dims.cols != rhs.getCols())
	{
		//matrices incompatible for addition
		Matrix::_errorMsg(MATRIX_ADD_ERROR);
	}
	//create new empty matrix to store within values
	Matrix res = Matrix(_dims.rows, rhs.getCols());
	for (int i = 0; i < res.getRows(); i++)
	{
		for (int j = 0; j < res.getCols(); j++)
		{
			res(i, j) = (*this)(i, j) + rhs(i, j);
		}
	}
	return res;
}

/**
     * accumalation addition for matrices. Both matrices must be of dims (m,n)
     * @param rhs matrix to add to this matrix
     * @return this matrix
     */
Matrix &Matrix::operator+=(const Matrix &rhs)
{
	if (_dims.rows != rhs.getRows() || _dims.cols != rhs.getCols())
	{
		Matrix::_errorMsg(MATRIX_ADD_ERROR);
	}
	for (int i = 0; i < _dims.rows; i++)
	{
		for (int j = 0; j < _dims.cols; j++)
		{
			(*this)(i, j) += rhs(i, j);
		}
	}
	return *this;
}

/**
     * parenthesis operator for matrices. Returns value in (i,j)th cell
     * @param row of value
     * @param col of value
     * @return value
     */
float &Matrix::operator()(const int row, const int col)
{
	if (row < 0 || row >= _dims.rows || col < 0 || col >= _dims.cols)
	{
		_errorMsg(OUT_OF_BOUNDS_ERROR);
	}
	return (*this)[row * _dims.cols + col];
}

/**
     * parenthesis operator for constant matrices. Returns value in (i,j)th cell
     * @param row of value
     * @param col of value
     * @return value
     */
const float &Matrix::operator()(const int row, const int col) const
{
	if (row < 0 || row >= _dims.rows || col < 0 || col >= _dims.cols)
	{
		_errorMsg(OUT_OF_BOUNDS_ERROR);
	}
	return (*this)[row * _dims.cols + col];
}


/**
     * square bracket operator for matrices. Returns value in (i* colDim + j)th cell
     * @param index of value
     * @return value
     */
float &Matrix::operator[](int index)
{
	if (index < 0 || index >= _dims.rows * _dims.cols)
	{
		_errorMsg(OUT_OF_BOUNDS_ERROR);
	}
	return _data[index];
}

/**
     * square bracket operator for constant matrices. Returns value in (i* colDim + j)th cell
     * @param index of value
     * @return value
     */
const float &Matrix::operator[](int index) const
{
	if (index < 0 || index >= _dims.rows * _dims.cols)
	{
		_errorMsg(OUT_OF_BOUNDS_ERROR);
	}
	return _data[index];
}

/**
     * Input stream Fills matrix elements, has to read input stream fully, otherwise,
     * that’s an error.
     * @param s input stream to read from
     * @param m matrix to read data into
     * @return input stream for concatenation
     */
istream &operator>>(istream &is, Matrix &m)
{
	//cast _data float to char* to read all bytes
	is.read((char *) m._data, m.getCols() * m.getRows() * sizeof(float));
	if (!is)
	{
		//encountered error while reading stream
		Matrix::_errorMsg(FILE_PARSING_ERROR);
	}
	return is;
}

/**
     * Output matrix in "grayscale" pixel form for user to output stream
     * @param s output stream
     * @param m matrix to be outputted
     * @return output stream for concatenation
     */
ostream &operator<<(ostream &os, const Matrix &m)
{
	for (int i = 0; i < m.getRows(); i++)
	{
		for (int j = 0; j < m.getCols(); j++)
		{
			if (m(i, j) <= THRESHOLD)
			{
				os << DOUBLE_SPACE;
			}
			else
			{
				os << DOUBLE_ASTERISK;
			}
		}
		os << std::endl;
	}
	return os;
}






����������������������������������������������������������������Matrix.h��������������������������������������������������������������������������������������������000755 �000765 �000024 �00000012046 13670724063 013641� 0����������������������������������������������������������������������������������������������������ustar�00tamarakov�����������������������staff���������������������������000000 �000000 ������������������������������������������������������������������������������������������������������������������������������������������������������������������������// Matrix.h

#ifndef MATRIX_H
#define MATRIX_H
//magic numbers, values for error messages
#define DEFAULT_DIM 1
#define MATRIX_DIMS_ERROR "Error: matrix dimensions are incorrect."
#define MATRIX_MULT_ERROR "Error: matrices dimensions are incompatible for multiplication."
#define MATRIX_ADD_ERROR "Error: matrices dimensions are incompatible for addition."
#define FILE_PARSING_ERROR "Error: file parsing unsuccessful"
#define SPACE ' ';
#define DOUBLE_SPACE "  ";
#define DOUBLE_ASTERISK "**";
#define THRESHOLD 0.1f
#define OUT_OF_BOUNDS_ERROR "Error: tried to access value outside matrix bounds"

#include <iostream>
#include <fstream>

//namespaces
using std::istream;
using std::ifstream;
using std::ostream;

/**
 * @struct MatrixDims
 * @brief Matrix dimensions container
 */
typedef struct MatrixDims
{
	int rows, cols;
} MatrixDims;

/**
//class for Matrix object, holds MatrixDims struct and pointer to array with float data
*/
class Matrix
{
private:
	MatrixDims _dims;
	float *_data;

	/**
	 * error printing function, exits program
	 * @param msg to be printed
	 */
	static void _errorMsg(const char *msg)
	{
		std::cerr << msg << std::endl;
		exit(EXIT_FAILURE);
	}

	/**
	 * helper function- copies all data into another matrix
	 * @param m matrix from which data is to be copied
	 */
	void _matrixDeepCopy(const Matrix &m);

public:
	/**
	 * c'tor- constructs Matrix rows × cols, inits all elements to 0
	 */
	Matrix(int rows, int cols);

	/**
	 * default c'tor- constructs 1×1 Matrix, inits the single element to 0,
	 * uses constructor delegation
	 */
	Matrix() : Matrix(DEFAULT_DIM, DEFAULT_DIM)
	{}

	/**
	 * Copy constructor- constructs matrix from another Matrix m.
	 * Uses constructor delegation, followed by deep copy of matrix data
	 * @param m matrix from which to create a copy
	 */
	Matrix(Matrix const &m) : Matrix(m.getRows(), m.getCols())
	{
		_matrixDeepCopy(m);
	}

	/**
	 * class destructor- deletes matrix data
	 */
	~Matrix()
	{ delete[] _data; };

	/**
	 * getter method
	 * @return number of cols in this matrix object
	 */
	const int &getCols() const
	{ return this->_dims.cols; }

	/**
	 * getter method
	 * @return number of rows in this matrix object
	 */
	const int &getRows() const
	{ return this->_dims.rows; }

	/**
	 * function makes a matrix of dimensions (m,n) into a vector of dimensions (m*n,1)
	 * @return vector version of matrix
	 */
	Matrix &vectorize();

	/**
	 *  Prints matrix elements, no return value. Prints space after each element (incl. last
	 *  element in the row). Prints newline after each row (incl. last row)
	 */
	void plainPrint() const;

	/**
	 * assignment operator for matrices
	 * @param rhs matrix from which to assign dimensions and values
	 * @return this matrix with updated dims and values
	 */
	Matrix &operator=(const Matrix &rhs);

	/**
	 * multiplication operator for matrices- must be of form M(m,n) * N(n,k)
	 * @param rhs matrix to multiply by
	 * @return new matrix with multiplication values
	 */
	Matrix operator*(const Matrix &rhs) const;

	/**
	 * Scalar multiplication by right operator for matrices
	 * @param rhs scalar by which to multiply all values in matrix
	 * @return this matrix
	 */
	Matrix &operator*(const float &rhs);

	/**
	 * Scalar multiplication by left operator for matrices
	 * @param rhs scalar by which to multiply all values in matrix
	 * @return matrix
	 */
	friend Matrix &operator*(float lhs, Matrix &rhs);

	/**
	 * Matrix addition operator. Both matrices must be of dims (m,n)
	 * @param rhs matrix to add to this matrix
	 * @return matrix with updated values
	 */
	Matrix operator+(const Matrix &rhs) const;

	/**
	 * accumalation addition for matrices. Both matrices must be of dims (m,n)
	 * @param rhs matrix to add to this matrix
	 * @return this matrix
	 */
	Matrix &operator+=(const Matrix &rhs);

	/**
	 * parenthesis operator for matrices. Returns value in (i,j)th cell
	 * @param row of value
	 * @param col of value
	 * @return value
	 */
	float &operator()(const int row, const int col);

	/**
	 * parenthesis operator for constant matrices. Returns value in (i,j)th cell
	 * @param row of value
	 * @param col of value
	 * @return value
	 */
	const float &operator()(const int row, const int col) const;

	/**
	 * square bracket operator for matrices. Returns value in (i* colDim + j)th cell
	 * @param index of value
	 * @return value
	 */
	float &operator[](int index);

	/**
	 * square bracket operator for constant matrices. Returns value in (i* colDim + j)th cell
	 * @param index of value
	 * @return value
	 */
	const float &operator[](int index) const;

	/**
	 * Input stream Fills matrix elements, has to read input stream fully, otherwise,
	 * that’s an error.
	 * @param s input stream to read from
	 * @param m matrix to read data into
	 * @return input stream for concatenation
	 */
	friend istream &operator>>(istream &is, Matrix &m);

	/**
	 * Output matrix in "grayscale" pixel form for user to output stream
	 * @param s output stream
	 * @param m matrix to be outputted
	 * @return output stream for concatenation
	 */
	friend ostream &operator<<(ostream &os, const Matrix &m);
};

#endif //MATRIX_H

������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������MlpNetwork.h����������������������������������������������������������������������������������������000755 �000765 �000024 �00000002067 13670724051 014476� 0����������������������������������������������������������������������������������������������������ustar�00tamarakov�����������������������staff���������������������������000000 �000000 ������������������������������������������������������������������������������������������������������������������������������������������������������������������������//MlpNetwork.h

#ifndef MLPNETWORK_H
#define MLPNETWORK_H

#include "Matrix.h"
#include "Digit.h"
#include "Dense.h"

#define MLP_SIZE 4

const MatrixDims imgDims = {28, 28};
const MatrixDims weightsDims[] = {{128, 784},
								  {64,  128},
								  {20,  64},
								  {10,  20}};
const MatrixDims biasDims[] = {{128, 1},
							   {64,  1},
							   {20,  1},
							   {10,  1}};

/**
 * class represents an MlpNetwork used to identify a digit from a 28x28 matrix of Grayscale pixel data
 */
class MlpNetwork
{
private:
	Matrix _weights[MLP_SIZE];
	Matrix _biases[MLP_SIZE];

public:
	/**
	 * class constructor
	 * @param weights weight matrices for each layer
	 * @param biases bias vectors for each layer
	 */
	MlpNetwork(const Matrix weights[MLP_SIZE], const Matrix biases[MLP_SIZE]);

	/**
	 * parenthesis operator for class: activate MlpNetwork on an input matrix
	 * @param input matrix representing a 28x28 grayscale pixel image
	 * @return Digit struct containing recognized digit and probability
	 */
	Digit operator()(Matrix &input);
};

#endif // MLPNETWORK_H
�������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������MlpNetwork.cpp��������������������������������������������������������������������������������������000644 �000765 �000024 �00000002363 13670725157 015035� 0����������������������������������������������������������������������������������������������������ustar�00tamarakov�����������������������staff���������������������������000000 �000000 ������������������������������������������������������������������������������������������������������������������������������������������������������������������������#include "MlpNetwork.h"
#include "Dense.h"

/**
     * class constructor
     * @param weights weight matrices for each layer
     * @param biases bias vectors for each layer
     */
MlpNetwork::MlpNetwork(const Matrix *weights, const Matrix *biases)
{
	for (int i = 0; i < MLP_SIZE; i++)
	{
		//matrix assignment operator
		_weights[i] = weights[i];
		_biases[i] = biases[i];
	}
}

/**
     * activate MlpNetwork on an input matrix
     * @param input matrix representing a 28x28 grayscale pixel image
     * @return Digit struct containing recognized digit and probability
     */
Digit MlpNetwork::operator()(Matrix &input)
{
	//create array of layers
	Dense layer[] =
			{
					Dense(_weights[0], _biases[0], Relu),
					Dense(_weights[1], _biases[1], Relu),
					Dense(_weights[2], _biases[2], Relu),
					Dense(_weights[3], _biases[3], Softmax)
			};
	//concatenate layer activations
	Matrix final = layer[3](layer[2](layer[1](layer[0](input))));
	unsigned int value = 0;
	float probability = 0.0f;
	//find maximum probability value of output matrix
	for (int i = 0; i < final.getRows(); i++)
	{
		if (final[i] > probability)
		{
			//update recognized digit and probability
			value = i;
			probability = final[i];
		}
	}
	return Digit{value, probability};
}

�����������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������Makefile��������������������������������������������������������������������������������������������000755 �000765 �000024 �00000000507 13667351662 013672� 0����������������������������������������������������������������������������������������������������ustar�00tamarakov�����������������������staff���������������������������000000 �000000 ������������������������������������������������������������������������������������������������������������������������������������������������������������������������CC=g++
CXXFLAGS= -Wall -Wvla -Wextra -Werror -g -std=c++17
LDFLAGS= -lm
HEADERS= Matrix.h Activation.h Dense.h MlpNetwork.h Digit.h
OBJS= Matrix.o Activation.o Dense.o MlpNetwork.o main.o

%.o : %.c


mlpnetwork: $(OBJS)
	$(CC) $(LDFLAGS) -o $@ $^

$(OBJS) : $(HEADERS)

.PHONY: clean
clean:
	rm -rf *.o
	rm -rf mlpnetwork




���������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������
